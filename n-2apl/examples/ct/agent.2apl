Beliefs:
useColor(Color) :- position(X,Y,Z),tile(Color,X,Y).
at(X,Y,Z) :- position(X,Y,W).
initialized :- event(game_initiatized), initialized(yes).
receivedP(closed(reject),_) :-receivedP(_,_,closed(reject)).
raise(X,NewX):- NewX is X + 1.
lower(X,NewX):- NewX is X - 1.

points(1000).
position(3, 3, 0).
clock(0).
initialized(no).
phase(none).


Goals:
initialized, update

BeliefUpdates:
{ clock(Old) } 												UpdateClock(New) 				{ not clock(Old), clock(New) }
{ points(X) } 												UpdatePoints(X1) 				{ not points(X), points(X1) }
{ position(X,Y,Clock) } 									UpdatePosition(X1,Y1,Clock) 	{ not position(X,Y,Clock), position(X1,Y1,Clock), moveTooFast(x)}
{ position(X,Y,Clock) and moveTooFast(x) } 					UpdatePosition(X1,Y1,Clock1) 	{ not position(X,Y,Clock), position(X1,Y1,Clock), not moveTooFast(x) }
{ position(X,Y,Clock) } 									UpdatePosition(X1,Y1,Clock1) 	{ not position(X,Y,Clock), position(X1,Y1,Clock)}
{ true } 													UpdateTile(Color,X,Y) 			{ tile(Color,X,Y) }
//{message(TYPE,ID,open)}										CloseMessage(TYPE,ID,RESPONSE)	{not message(TYPE,ID,open), message(TYPE,ID,RESPONSE)}
{true} 														Failed(X) 						{failed(X)}
{chipsNeeded(OLD) or not chipsNeeded(OLD)}					GetChipsNeeded(NEW)				{not chipsNeeded(OLD), chipsNeeded(NEW)}
{chipsRedundant(OLD) or not chipsRedundant(OLD)}			GetChipsRedundant(ID,NEW)		{not chipsRedundant(OLD), chipsRedundant(NEW)}
{true}														GetAgentId(NEW)					{agentId(NEW)}
{true} 														GetAgentPin(X)	 				{agentPin(X)}
{agentPos(OLDX,OLDY) or not agentPos(OLDX,OLDY)} 			GetAgentPos(X,Y) 				{not agentPos(OLDX,OLDY), agentPos(X,Y)}
{true}														GetRole(ID, ROLE)				{role(ID,ROLE)}
{goalId(ID) or not goald(ID)}								GetGoalId(NEWID)				{not goalId(ID), goalId(NEWID)}
{goalPos(TYPE,OLDX,OLDY) or not goalPos(TYPE,OLDX,OLDY)}	GetGoalPos(TYPE,X,Y) 			{not goalPos(TYPE,OLDX,OLDY), goalPos(TYPE,X,Y)}
{chips(PLAYER,CHIPSOLD) or not chips(PLAYER,CHIPSOLD)}		GetChips(PLAYER,CHIPS)			{not chips(PLAYER,CHIPSOLD), chips(PLAYER,CHIPS)}
{agentChips(L) or not agentChips(L)}  						GetAgentChips(LNEW)				{not agentChips(L), agentChips(LNEW)}
{opponentChips(L) or not opponentChips(L)}					GetOpponentChips(LNEW)			{not opponentChips(L), opponentChips(LNEW)}
{true}														GetOpponentId(ID)				{opponentId(ID)}
{true}														GetOpponentPin(PIN)				{opponentPin(PIN)}
{phase(Old)}												GetPhase(Pp)					{not phase(Old), phase(Pp)}
{opponentPos(OLDX,OLDY) or not opponentPos(OLDX,OLDY)}		GetOpponentPos(X,Y)				{not opponentPos(OLDX,OLDY), opponentPos(X,Y)}
{initialized(X)}											Initialize() 					{not initialized(X), initialized(yes), not event(game_initialized)}
{score(ID,OLD) or not score(ID,OLD)}    					GetScore(ID,SCORE)				{not score (ID,OLD), score(ID,SCORE)}
{scoreCurrentChips(ID,OLD) or not scoreCurrentChips(ID,OLD)}	GetScoreCurrentChips(ID,S)	{not scoreCurrentChips(ID,OLD), scoreCurrentChips(ID,S)}
{scoreAfterExchange(ID,OLD) or not scoreAfterExchange(ID,OLD)}GetScoreAfterExchange(ID,SCORE)	{not scoreAfterExchange(ID,OLD), scoreAfterExchange(ID,SCORE)}
{true}														MakeProposal(X)					{proposal(X)}
{true}														MakeResponse(ID)				{response(ID)}
{true}														MoveStepToGoal(MOVED)			{moved(MOVED)}
{event(phasechange)}                                        Updated()                       {not event(phasechange)}
{true}														ReceivedEvent(X)				{event(X)}
{sent(Pp,ID,open)}											ReceivedMessage(RESPONSE,ID)	{not sent(Pp,ID,open), sent(Pp,ID,closed(RESPONSE))}
{true}														ReceivedMessage(TYPE,ID,STATUS) {received(TYPE,ID,STATUS)}
{true}														ReceivedProposal(TYPE,ID,STATUS){receivedP(TYPE,ID,STATUS)}
{requestChips(X,Y) or not requestChips(X,Y)}				RequestChips(PIN,CHIPS)			{not requestChips(X,Y), requestChips(PIN,CHIPS)}
// sent a proposal
{true}														Sent(TYPE,ID,STATUS)		    {sent(TYPE,ID,STATUS)}
// sent an answer
{received(proposal,ID,open)}								Sent(ANSWER,ID)					{not receivedP(proposal,ID,open), receivedP(proposal,ID,closed(ANSWER))}
  
//Plans:
//initialize()

PG-rules:

surround(X,Y) <- role(ID,ra) | {
	[
//	Surround(X,Y);
	sendSouth(a10,X,Y,100);
	sendWest(a20,X,Y,100);
	sendEast(a30,X,Y,100);
	sendNorth(a40,X,Y,100);
	color(white,a10,yes,100);
	color(white,a20,yes,100);
	color(white,a30,yes,100);
	color(white,a40,yes,100);
	color(blue,a10,no,100);
	color(blue,a20,no,100);
	color(blue,a30,no,100);
	color(blue,a40,no,100);
	dropgoal(surround(X,Y))
	]
} : 150

useColor(Color) <- phase(movementphase) or phase(communicationphase) | { //not the closest one
	[B(clock(Clock));
	G(at(X,Y,_));
	moveStepToGoal(Color,X,Y,Clock)]
} : 100

//makeMove(X,Y) <- true | {}

//propose <- phase(communicationphase) and not sent(Pp,ID,open) | makeProposal()
//respond <- received(TYPE,ID,open) and phase(communicationphase) | makeResponse(ID)

received(TYPE,ID,closed) <- phase(communicationphase) | makeResponse(ID)
receivedP(TYPE,ID,accept) <- phase(communicationphase) | makeResponse(ID)

initialized <- event(game_initialized) | {
   // dropgoal(initialized);
    Initialize()
}

update <- event(phasechange) | update()

at(X,Y,C) <- phase(communicationphase) or phase(movementphase) | {

  [moveStepToGoal(neco,X,Y,C)]
    
} : 100

PC-rules:

sendNorth(Agent,X,Y,S) <- raise(Y,Y1) and gsurround(GX,GY) | {
	@ctenv( setGoal(Agent,X,Y1,GX,GY,S),L)
}
sendSouth(Agent,X,Y,S) <- lower(Y,Y1) and gsurround(GX,GY) | {
	@ctenv( setGoal(Agent,X,Y1,GX,GY,S),L)
}
sendEast(Agent,X,Y,S) <- raise(X,X1) and gsurround(GX,GY) | {
	@ctenv( setGoal(Agent,X1,Y,GX,GY,S),L)
}
sendWest(Agent,X,Y,S) <- lower(X,X1) and gsurround(GX,GY) | {
	@ctenv( setGoal(Agent,X1,Y,GX,GY,S),L)
}

color(Color,Agent,Yes,S) <- true | {
	@ctenv( setColor(Agent,Color,Yes,S),L)
}

update() <- true | {
	getPhase();
    B(clock(Clock));
    if B(event(phasechange)) then Updated()
}

getId() <- true | {
	@ctenv( getAgentId(), L1);
	B( L1 = [actionresult(X)]);
	GetAgentId(X)
}

getPhase() <- true | {
	@ctenv( getPhase(), L1);
	B( L1 = [actionresult(X)]);
	GetPhase(X)
}


getPos() <- true | {
	@ctenv( getAgentPos(), L1);
	B( L1 = [actionresult(  [X,Y] )]);
	GetAgentPos(X,Y)
}


// Returns the additional chips that the agent needs to reach its goal
getChipsNeeded(OPPID) <- true | {
	@ctenv( getChipsNeeded(OPPID), L1);
	B( L1 = [actionresult(X)]);
	GetChipsNeeded(X)
}

getChips() <- true | {
	@ctenv( getAgentChips(), L1);
	B( L1 = [actionresult(X)]);
	GetAgentChips(X)
}

getChipsRedundant() <- agentId(ID) | {
    @ctenv( getChipsRedundant(ID), L1);
    B( L1 = [actionresult(X)]);
	GetChipsRedundant(ID,X)
}

getOpponentChips() <- opponentPin(PIN) | {
	@ctenv( getOpponentChips(PIN), L1);
	B( L1 = [actionresult(X)]);
	GetOpponentChips(X)
}

getGoalId(TYPE,X,Y) <- true | {
	@ctenv( getGoalId(TYPE,X,Y), L1);
	if B( L1 = [actionresult(ID)]) then
		GetGoalId(ID)
}

getGoalId() <- goalPos(TYPE,X,Y) | {
	@ctenv( getGoalId(TYPE,X,Y), L1);
	if B( L1 = [actionresult(ID)]) then
		GetGoalId(ID)
}

getGoalPos(TYPE) <- true | {
	@ctenv( getGoalPos(TYPE), L1);
	if B( L1 = [actionresult([X,Y])]) then
		GetGoalPos(TYPE,X,Y)
}

// TODO: can only deal with one opponent...
getOpponentPin() <- true | {
	@ctenv( getOpponentPin(), L1);
	B( L1 = [actionresult(X)]);
	GetOpponentPin(X)
}

// TODO: can only deal with one opponent... 
getOpponentId() <- true | {
	@ctenv( getOpponentId(), L1);
	B( L1 = [actionresult(X)]);
	GetOpponentId(X)
}

// TODO: can only deal with one opponent...
getOpponentPos() <- true | {
	@ctenv( getOpponentPos(), L1);
	B( L1 = [actionresult([X,Y])]);
	GetOpponentPos(X,Y)	
}

getPin() <- true | {
	@ctenv( getAgentPin(), L1);
	B( L1 = [actionresult(X)]);
	GetAgentPin(X)
}


getRole(ID) <- true | {
	@ctenv( getRole(ID), L1);
	B( L1 = [actionresult(X)]);
	GetRole(ID, X)
}

getScoreAfterExchange(ID,MSGID) <- true | {
	@ctenv( getScoreAfterExchange(ID,MSGID), L1);
	B( L1 = [actionresult(X)]);
	GetScoreAfterExchange(ID,X)
}

getScoreAfterExchange(ID,CHIPS) <- true | {
	@ctenv( getScoreAfterExchange(ID,CHIPS), L1);
	B( L1 = [actionresult(X)]);
	GetScoreAfterExchange(ID,X)
}

getScore(ID) <- true | {
	@ctenv( getScore(ID), L1);
	B( L1 = [actionresult(X)]);
	GetScore(ID,X)
}	

getScoreCurrentChips(ID) <- true | {
	@ctenv( getScoreCurrentChips(ID), L1);
	B( L1 = [actionresult(X)]);
	GetScoreCurrentChips(ID,X)
}

initialize() <- initialized(no) | {
    getPhase();
    getId();
    B(agentId(ID));
    getRole(ID)
}

// TODO: give a goalidentifier to requestChips
requestChips(OPPPIN) <- opponentId(OPPID) | {
	@ctenv(requestChips(OPPPIN,OPPID), L1);
	B( L1 = [actionresult(X)]);
	RequestChips(OPPID,X)
}

sendProposal(PIN, CHIPS) <- true | {
	@ctenv( sendProposal(PIN,CHIPS), L1);
	B( L1 = [actionresult(X)]);
	Sent(proposal,X,open)
}

sendProposal() <- true | {
	@ctenv( sendProposal(), L1);

	//B( L1 = [actionresult(X)]);
	Sent(proposal,1,open)

}

makeProposal()<- opponentPin(PIN) and agentId(ID) | {
	//GetchipsRedundant(ID,CHIPS);
	sendProposal()
}

makeResponse(MSGID) <- true | {
	sendResponse(accept,MSGID)
}

// send a response to the proposer of a proposal that is still open
// the id of the proposer does not have to be included 
// RESPONSE = {accept,reject}
sendResponse(RESPONSE,MSGID) <- received(proposal,MSGID,open) | {
	@ctenv( sendResponse(RESPONSE,MSGID), L1); 
	Sent(RESPONSE,MSGID);
	dropgoal(received(proposal,MSGID,closed))
}	

moveStepToGoal(ID,X,Y,C) <- true | {
	@ctenv( moveStepToGoal(ID,X,Y), L1);
	B( L1 = [actionresult(Z)]);
	B(clock(Clock));
	MoveStepToGoal(Z);
	B(position(X1,Y1,_));
	if 	B([A,B] = Z) then {
		if B(not [X1,Y1] = Z)  then {
		UpdatePosition(A,B,Clock)
		}
	}
}

///////////// Moving

moveTo(X,Y) <- position(X2,Y2,_) and Y2 < Y and raise(Y2,NewY) | { 
    updatePos(X2,NewY); moveTo(X,Y)
}
moveTo(X,Y) <- position(X2,Y2,_) and X2 < X and raise(X2,NewX) | { 
    updatePos(NewX,Y2); moveTo(X,Y)
}
moveTo(X,Y) <- position(X2,Y2,_) and X2 > X and lower(X2,NewX) | { 
    updatePos(NewX,Y2); moveTo(X,Y)
}
moveTo(X,Y) <- position(X2,Y2,_) and Y2 > Y and lower(Y2,NewY) | { 
    updatePos(X2,NewY); moveTo(X,Y)
}
moveTo(X,Y) <- position(X,Y,_) | { skip }

updatePos(NewX,NewY) <- position(X,Y,_) | {
    
    B(clock(Clock));
    UpdatePosition(NewX,NewY,Clock)
//  @ctenv(write(status(position(NewX,NewY),Clock),-1),_)   
} 

event(obligation([Goal],Deadline,[Sanction]),ctenv) <- true | {
   adoptObligation(Goal, Deadline, Sanction)
}

event(prohibition([State],[Sanction]),ctenv) <- true | {
   adoptProhibition(State,Sanction)
}

event(clock(Clock),ctenv) <- true | {
   UpdateClock(Clock)
}
event(points(Points),ctenv) <- true | {
   UpdatePoints(Points)
}
event(position(X,Y,Clock),ctenv) <- true | {
   UpdatePosition(X,Y,Clock)
}
event(tile(Color,X,Y,Clock),ctenv) <- true | {
   UpdateTile(Color,X,Y)
}

event(FUNCTION, NAME) <- true | {
	@ctenv( functionToList(FUNCTION), LIST); 
	if B(LIST=[actionresult([TYPE,ID])]) then { 
		//Received a proposal
		if B(TYPE=proposal) then {
			ReceivedMessage(TYPE,ID,open);
			//make response
			adopta(received(TYPE,ID,closed))
		}
	}
	else if B(LIST=[actionresult([TYPE,ID,RESPONSE])]) then {	
		// Received a response
		if B(TYPE=response) then {
			ReceivedMessage(RESPONSE,ID)
		} 
	}
	else if B(LIST=[actionresult([TYPE])]) then {
		// Received an event
		ReceivedEvent(TYPE)
	}
	else if B(LIST=[actionresult([TYPE,AGENT,ID,RESPONSE])]) then {	
		// Received a proposal
		if B(TYPE=proposal) then {
			ReceivedProposal(AGENT,ID,RESPONSE)
			//adopta(receivedP(AGENT,ID,RESPONSE))
		}
	}	
}



adoptProhibition(at(X,Y,_), reduce(_,Value)) <- clock(Clock) | {
    aprohibition(at(X,Y,Clock) -> reduce(Value))
}
adoptProhibition(color(Color,Thing), reduce(_,Value)) <- true | {
    aprohibition(useColor(Color) -> reduce(Value))
}
adoptProhibition(rejectRequests(Thing), reduce(_,Value)) <- true | {
    aprohibition(receivedP(closed(reject),Thing) -> reduce(Value))
}
adoptProhibition(moveTooFast(Thing), reduce(_,Value)) <- true | {
    aprohibition(moveTooFast(x) -> reduce(Value))
}

//{	adoptProhibition(rejectRequests(a40), reduce(a40, 500))
//},
//{	adoptProhibition(moveTooFast(a40), reduce(a40, 300))
//}

adoptObligation(at(X,Y,_), D, reduce(_,Value)) <- clock(Clock) | {
    adopta(at(X,Y,Clock) : D -> reduce(Value))
}
adoptObligation(surround(X,Y), D, reduce(Group,Sanction)) <- true | {
    adopta(surround(X,Y) : D -> reduce(Sanction))
}
adoptObligation(color(Color,Thing), D, reduce(Group,Sanction)) <- true | {
    adopta(useColor(Color) : D -> reduce(Sanction))
}
adoptObligation(acceptRequests(Thing), D, reduce(Group,Sanction)) <- true | {
    adopta(acceptRequests : D -> reduce(Sanction))
}
adoptObligation(makeMove(X,Y,Thing), D, reduce(Group,Sanction)) <- true | {
    adopta(makeMove(X,Y) : D -> reduce(Sanction))
}

Sanctions:
	reduce(50)  -> 1,
	reduce(100) -> 2,
	reduce(150) -> 3,
	reduce(200) -> 4,
	reduce(250) -> 5,
	reduce(300) -> 6,
	reduce(400) -> 7, 
	reduce(500) -> 8,
	reduce(700) -> 9,
	reduce(1000) -> 10
