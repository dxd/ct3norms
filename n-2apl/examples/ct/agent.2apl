Beliefs:
wingame :- reachedGoal. 
reachedGoal :- goalPos(0,X,Y) , agentPos(X,Y).
received(X,Y,closed) :- received(X,Y,closed(Z)).
useColor(Color) :- position(X,Y,Z),tile(Color,X,Y).
at(X,Y,Z) :- position(X,Y,W).
initialized :- event(game_initiatized), initialized(yes).
initialized(no).
phase(none).
color(Color):- position(X,Y,C),
	tile(Color,X,Y).
receivedP(closed(reject),_) :-receivedP(_,_,closed(reject)).

  raise(X,NewX):- NewX is X + 1.
  lower(X,NewX):- NewX is X - 1.

  points(1000).
  position(3, 3, 0).
  clock(0).


Goals:
initialized, wingame, update

BeliefUpdates:
  { clock(Old) } UpdateClock(New) { not clock(Old), clock(New) }
  { true } AddReading(at(X,Y),Value,Agent,Clock) { reading(at(X,Y),Value,Agent,Clock) }
  { points(X) } UpdatePoints(X1) { not points(X), points(X1) }
  { position(X,Y,Clock) } UpdatePosition(X1,Y1,Clock) { not position(X,Y,Clock), position(X1,Y1,Clock), moveTooFast(x)}
  { position(X,Y,Clock) and moveTooFast(x) } UpdatePosition(X1,Y1,Clock1) { not position(X,Y,Clock), position(X1,Y1,Clock), not moveTooFast(x) }
  { position(X,Y,Clock) } UpdatePosition(X1,Y1,Clock1) { not position(X,Y,Clock), position(X1,Y1,Clock)}
  { true } UpdateTile(Color,X,Y) { tile(Color,X,Y) }

PG-rules:
//acceptRequests <- true | {

//}

useColor(Color) <- phase(movementphase) or phase(communicationphase) | { //not the closest one
	[B(clock(Clock));
	G(at(X,Y,_));
	moveStepToGoal(Color,X,Y,Clock)]
//	B(position(X1,Y1,_))
///	if B(tile(Color,X1,Y1)) then
//			dropgoal(useColor(Color))
//		else
//			moveStepToGoal(Color,X,Y,Clock)]
} : 100

//makeMove(X,Y) <- true | {

//}
//propose <- phase(communicationphase) and not sent(Pp,ID,open) | makeProposal()

//respond <- received(TYPE,ID,open) and phase(communicationphase) | makeResponse(ID)

received(TYPE,ID,closed) <- phase(communicationphase) | makeResponse(ID)
receivedP(TYPE,ID,accept) <- phase(communicationphase) | makeResponse(ID)

initialized <- event(game_initialized) | {
    dropgoal(initialized);
    Initialize()
}

update <- event(phasechange) | update()
//update <- event(normphase) and ra | sendNorms()
update <- phase(communicationphase) and role(X,proposer) and not sent(Pp,ID,open) | makeProposal()
//update <- phase(movementphase) | moveStepToGoal()

at(X,Y,C) <- phase(communicationphase) or phase(movementphase) | {

  [moveStepToGoal(neco,X,Y,C)
//  B(position(X1,Y1,_));
//	if B([X1,Y1] = [X,Y]) then
// 		dropgoal(at(X,Y,C))
// 	else
// 		moveStepToGoal(neco,X,Y,C)
  ]
    
} : 100

PC-rules:
moveStepToGoal(ID,X,Y,C) <- true | {

	@ctenv( moveStepToGoal(ID,X,Y), L1);
	B( L1 = [actionresult(Z)]);
	B(clock(Clock));
	MoveStepToGoal(Z);
	B(position(X1,Y1,_));
	if 	B([A,B] = Z) then {
		if B(not [X1,Y1] = Z)  then {
		UpdatePosition(A,B,Clock)
		}
	}
}

///////////// Moving

moveTo(X,Y) <- position(X2,Y2,_) and Y2 < Y and raise(Y2,NewY) | { 
    updatePos(X2,NewY); moveTo(X,Y)
}
moveTo(X,Y) <- position(X2,Y2,_) and X2 < X and raise(X2,NewX) | { 
    updatePos(NewX,Y2); moveTo(X,Y)
}
moveTo(X,Y) <- position(X2,Y2,_) and X2 > X and lower(X2,NewX) | { 
    updatePos(NewX,Y2); moveTo(X,Y)
}
moveTo(X,Y) <- position(X2,Y2,_) and Y2 > Y and lower(Y2,NewY) | { 
    updatePos(X2,NewY); moveTo(X,Y)
}
moveTo(X,Y) <- position(X,Y,_) | { skip }

updatePos(NewX,NewY) <- position(X,Y,_) | {
    
    B(clock(Clock));
    UpdatePosition(NewX,NewY,Clock)
  //  @ctenv(write(status(position(NewX,NewY),Clock),-1),_)   
} 

event(obligation([Goal],Deadline,[Sanction]),ctenv) <- true | {
   adoptObligation(Goal, Deadline, Sanction)
}

event(prohibition([State],[Sanction]),ctenv) <- true | {
   adoptProhibition(State,Sanction)
}

event(clock(Clock),ctenv) <- true | {
   UpdateClock(Clock)
}
event(points(Points),ctenv) <- true | {
   UpdatePoints(Points)
}
event(position(X,Y,Clock),ctenv) <- true | {
   UpdatePosition(X,Y,Clock)
}
event(tile(Color,X,Y,Clock),ctenv) <- true | {
   UpdateTile(Color,X,Y)
}

event(FUNCTION, NAME) <- true | {
	@ctenv( functionToList(FUNCTION), LIST); 
	if B(LIST=[actionresult([TYPE,ID])]) then { 
		//Received a proposal
		if B(TYPE=proposal) then {
			ReceivedMessage(TYPE,ID,open);
			//make response
			adopta(received(TYPE,ID,closed))
		}
	}
	else if B(LIST=[actionresult([TYPE,ID,RESPONSE])]) then {	
		// Received a response
		if B(TYPE=response) then {
			ReceivedMessage(RESPONSE,ID)
		} 
	}
	else if B(LIST=[actionresult([TYPE])]) then {
		// Received an event
		ReceivedEvent(TYPE)
	}
	else if B(LIST=[actionresult([TYPE,AGENT,ID,RESPONSE])]) then {	
		// Received a proposal
		if B(TYPE=proposal) then {
			ReceivedProposal(AGENT,ID,RESPONSE)
			//adopta(receivedP(AGENT,ID,RESPONSE))
		}
	}	
}



adoptProhibition(at(X,Y,_), reduce(_,Value)) <- true | {
	B(clock(Clock));
    aprohibition(at(X,Y,Clock) -> reduce(Value))
}
adoptProhibition(color(Color,Thing), reduce(_,Value)) <- true | {
    aprohibition(color(Color) -> reduce(Value))
}
adoptProhibition(rejectRequests(Thing), reduce(_,Value)) <- true | {
    aprohibition(receivedP(closed(reject),Thing) -> reduce(Value))
}
adoptProhibition(moveTooFast(Thing), reduce(_,Value)) <- true | {
    aprohibition(moveTooFast(x,Thing) -> reduce(Value))
}
adoptObligation(at(X,Y,_), D, reduce(_,Value)) <- true | {
	B(clock(Clock));
    adopta(at(X,Y,Clock) : D -> reduce(Value))
}
adoptObligation(surround(X,Y), D, reduce(Group,Sanction)) <- true | {
    adopta(surround(X,Y) : D -> reduce(Sanction))
}
adoptObligation(color(Color,Thing), D, reduce(Group,Sanction)) <- true | {
    adopta(useColor(Color) : D -> reduce(Sanction))
}
adoptObligation(acceptRequests(Thing), D, reduce(Group,Sanction)) <- true | {
    adopta(acceptRequests : D -> reduce(Sanction))
}
adoptObligation(makeMove(X,Y,Thing), D, reduce(Group,Sanction)) <- true | {
    adopta(makeMove(X,Y) : D -> reduce(Sanction))
}

Sanctions:
	reduce(50)  -> 1,
	reduce(100) -> 2,
	reduce(150) -> 3,
	reduce(200) -> 4,
	reduce(250) -> 5,
	reduce(300) -> 6,
	reduce(400) -> 7, 
	reduce(500) -> 8,
	reduce(700) -> 9,
	reduce(1000) -> 10
